From: Matthew Brett <matthew.brett@gmail.com>
Subject: BF: work around sympy handling of longcomplex
  Sympy does not handle np.longcomplex correctly at the moment, and this started
raising an error with Sympy 1.1, released recently. It was discarding the
imaginary part before, so no real loss.  See:

https://github.com/sympy/sympy/pull/12901

for a proposal for proper handling of np.longcomplex.  In the mean time, don't
use it for testing.

--- a/nipy/core/reference/coordinate_map.py
+++ b/nipy/core/reference/coordinate_map.py
@@ -641,7 +641,7 @@ class AffineTransform(object):
             return None
         except TypeError:
             # Try using sympy for the inverse.  This might be needed for sympy
-            # symbols in the affine, or Float128
+            # symbols in the affine, or Float128, or complex numbers.
             from sympy import Matrix, matrix2numpy
             sym_inv = Matrix(self.affine).inv()
             m_inv = matrix2numpy(sym_inv).astype(aff_dt)
--- a/nipy/core/reference/tests/test_coordinate_map.py
+++ b/nipy/core/reference/tests/test_coordinate_map.py
@@ -941,6 +941,9 @@ def test_dtype_cmap_inverses():
     # CoordinateMap versions of AffineTransforms
     dtypes = (np.sctypes['int'] + np.sctypes['uint'] + np.sctypes['float']
               + np.sctypes['complex'] + [np.object])
+    # Sympy <= 1.1 does not handle numpy longcomplex correctly. See:
+    # https://github.com/sympy/sympy/pull/12901
+    dtypes.remove(np.longcomplex)
     arr_p1 = np.eye(4)[:, [0, 2, 1, 3]]
     in_list = [0, 1, 2]
     out_list = [0, 2, 1]
@@ -956,7 +959,10 @@ def test_dtype_cmap_inverses():
         else:
             exp_i_dt = dt
         # Default inverse cmap may alter coordinate types
-        r_cmap = cmap.inverse()
+        try:
+            r_cmap = cmap.inverse()
+        except:
+            1/0
         res = r_cmap(out_coord)
         assert_array_equal(res, coord)
         assert_equal(res.dtype, exp_i_dt)
